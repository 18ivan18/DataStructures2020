/***********************************************************************
  Задача 4. “Разредена матрица” наричаме структура от данни,
  представяща матрица A(MxN), състояща се от елементи от произволен
  тип, чиито стойности могат да се инициализират с константата 0 и да
  се сравняват с операторите == и !=. С всеки елемент могат да се
  извършват операциите присвояване на стойност и четене на
  стойност. При конструиране по подразбиране, елементите на матрицата
  се инициализират с 0. Структурата от данни “разредена матрица”
  трябва да удовлетворява следните изисквания за сложност (с n е
  означен броя на ненулевите елементи):

  * Използваната от матрицата памет да расте линейно спрямо броя
  ненулеви елементи, т.е. структурата трябва да има сложност по памет
  O(n).
  * Сложността по време за достъп до елемент на матрицата да е
  най-много логаритмична, т.е. O(log n).

  Да се дефинира шаблон на клас SparseMatrix, представящ разредена
  матрица, който да поддържа следните операции:

  1. Метод isZeroRow(row), който да проверява дали всички елементи на
  даден ред от матрицата са нулеви.

  2. Ако m е матрица, да се поддържа конструкцията for(unsigned int i
  : m) {...}, с която могат да се обходят индексите на всички редове,
  в които има поне един ненулев елемент.
  Упътване: може да използвате помощен клас или обект за обхождане на
  ненулевите редове.

  3. Метод set(i, j, value), който задава стойност value на елемента
  aᵢ,ⱼ.

  4. Оператор за индексиране в константна форма, който по индекс на
  ред и колона дава достъп за четене на елемент, например a[i][j]. Ако
  позицията е невалидна, операторът да връща константата 0.
  Внимание: тъй като операторът не променя стойности на елементи,
  извикването му не трябва да води до заделяне на допълнителна памет!
  Упътване: може да използвате помощен клас, описващ ред на
  матрицата.

  5. Да се дефинират оператори + и += за събиране на разредени
  матрици. Резултатът да е разредена матрица, отговаряща на
  изискването за сложност по памет.
  Бонус: Да се предложат подходящи тестове за тези оператори.
************************************************************************/

/***********************************************************************
 РЕШЕНИЕ:
************************************************************************/


/***********************************************************************
 КРАЙ НА РЕШЕНИЕТО
************************************************************************/

#define DOCTEST_CONFIG_IMPLEMENT
#include "doctest.h"

/***********************************************************************
  РАЗКОМЕНТИРАЙТЕ СЛЕДВАЩИЯ РЕД, ЗА ДА ВКЛЮЧИТЕ ТЕСТОВЕТЕ
************************************************************************/
// #include "task4_tests.h"

int main ()
{
    // пускане на тестовете
    doctest::Context().run();
    return 0;
}
